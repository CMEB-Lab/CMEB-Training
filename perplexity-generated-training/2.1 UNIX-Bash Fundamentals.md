<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# UNIX/Bash Fundamentals Training Manual (Module 2.1)

**A Comprehensive 20-Hour Competency-Based Learning Program**

## Executive Overview

This training manual provides a systematic approach to mastering UNIX/Bash fundamentals specifically designed for bioinformatics applications. Built on competency-based learning principles, this module transforms complete beginners into proficient command-line users capable of handling bioinformatics file formats, quality control procedures, and automated workflows essential for technical interviews and professional practice.

## Module Specifications

### Learning Objectives

By completion of this module, learners will demonstrate mastery of:

1. **File System Navigation**: Navigate complex directory structures, understand path specifications, and manipulate file permissions[^1][^2]
2. **Text Processing Mastery**: Employ grep, awk, and sed for sequence file validation and quality assessment[^3][^4]
3. **Automation Skills**: Create reproducible shell scripts with pipes, redirection, and error handling[^5][^6]
4. **Bioinformatics Integration**: Apply UNIX tools to FASTQ quality control and validation workflows[^7][^8]

### Prerequisites Assessment

**Essential Background**: None assumed - this module is designed for absolute beginners
**Technical Requirements**: Access to UNIX/Linux environment (local installation, WSL, or cloud-based system)
**Time Commitment**: 20 hours structured learning over 2 weeks

## Week 1: Foundation Building

### Day 1: Essential Commands and Navigation (3 hours)

#### Core Command Set

**File System Operations**[^1][^2]:

```bash
# Directory navigation
pwd                    # Print working directory
ls -la                # Long listing with hidden files
cd ~                  # Change to home directory
cd ../                # Move up one directory level
cd /absolute/path     # Absolute path navigation
```

**File Manipulation Fundamentals**[^9]:

```bash
# Creating and viewing files
cat filename          # Display file contents
cat > newfile         # Create file with input
head -n 10 file       # Show first 10 lines
tail -n 10 file       # Show last 10 lines
wc -l filename        # Count lines in file
```


#### Hands-on Exercise 1: Bioinformatics File Structure

Create a realistic bioinformatics directory structure:

```bash
mkdir -p ~/bioproject/{raw_data,processed,scripts,results}
cd ~/bioproject/raw_data
echo -e "@read1\nATCGATCG\n+\n########" > sample1.fastq
ls -la
pwd
```


### Day 2: File Permissions and Security (2 hours)

#### Permission System Mastery[^10][^11]

**Understanding Permission Structure**:

- Read (r=4), Write (w=2), Execute (x=1)
- User, Group, Other permission classes
- Octal notation (755, 644, etc.)

```bash
-rwxr-xr--
```

This string can be broken down as follows: 
- First character: File type (`-` for regular file, `d` for directory, `l` for symlink, etc.).
- Next nine characters: Three sets of three, each representing permissions for:
- Owner (user who created the file)
- Group (users belonging to the file’s group)
- Others (everyone else)

Each set contains:
- r: read
- w: write
- x: execute

A dash (`-`) means that particular permission is not granted.
For example, `-rw-r--r--` means:
- Owner: read and write
- Group: read only
- Others: read only
	
**Practical Permission Management**[^12]:

```bash
# View current permissions
ls -l filename

# Modify permissions using symbolic notation
chmod u+x script.sh           # Add execute for user
chmod go-w filename           # Remove write for group/others
chmod a+r filename            # Add read for all

# Modify permissions using octal notation
chmod 755 script.sh           # rwxr-xr-x
chmod 644 data.txt           # rw-r--r--
```


#### Hands-on Exercise 2: Script Security

```bash
# Create a bioinformatics processing script
cat > quality_check.sh << 'EOF'
#!/bin/bash
echo "Starting quality assessment..."
fastqc *.fastq
EOF

# Set appropriate permissions
chmod 755 quality_check.sh
ls -l quality_check.sh
```


### Day 3: Text Processing Foundations (4 hours)

#### The Power Trinity: grep, sed, awk[^3][^4]

**grep: Pattern Searching**[^3]:

```bash
# Basic pattern matching
grep "ERROR" logfile.txt
grep -i "warning" logfile.txt      # Case-insensitive
grep -n "pattern" file            # Show line numbers
grep -v "exclude" file            # Invert match
grep -c "count" file              # Count matches

# Regular expressions
grep -E "[0-9]{3}-[0-9]{3}-[0-9]{4}" contacts.txt
```

**sed: Stream Editing**[^4]:

```bash
# Basic substitution
sed 's/old/new/' filename         # Replace first occurrence
sed 's/old/new/g' filename        # Replace all occurrences
sed -i 's/old/new/g' filename     # In-place editing

# Advanced operations
sed -n '1,10p' file               # Print lines 1-10
sed '/pattern/d' file             # Delete lines matching pattern
```

**awk: Pattern Processing**[^4]:

```bash
# Field-based processing
awk '{print $1, $3}' file         # Print columns 1 and 3
awk -F'\t' '{print $2}' file      # Tab-delimited input
awk '/pattern/ {print $0}' file   # Print lines matching pattern

# Mathematical operations
awk '{sum += $1} END {print sum}' numbers.txt
```


#### Hands-on Exercise 3: FASTQ Processing

```bash
# Create sample FASTQ data
cat > sample.fastq << 'EOF'
@read1
ATCGATCGATCG
+
############
@read2
GCTAGCTAGCTA
+
IIIIIIIIIIII
EOF

# Extract sequence IDs
grep "^@" sample.fastq

# Count total reads
grep -c "^@" sample.fastq

# Extract sequences only
sed -n '2~4p' sample.fastq

# Calculate sequence lengths
sed -n '2~4p' sample.fastq | awk '{print length($0)}'
```


### Day 4: Pipes and Redirection Mastery (3 hours)

#### Stream Manipulation[^13][^14]

**Redirection Operators**[^14]:

```bash
# Output redirection
command > file              # Redirect stdout to file (overwrite)
command >> file             # Redirect stdout to file (append)
command 2> file             # Redirect stderr to file
command &> file             # Redirect both stdout and stderr

# Input redirection
command < inputfile         # Read from file
command << EOF              # Here document
```

**Pipeline Construction**[^13]:

```bash
# Basic piping
ls -la | grep "fastq"
cat file | grep pattern | wc -l
ps aux | grep python | awk '{print $2}'

# Complex pipelines
find . -name "*.fastq" | xargs grep -c "^@" | sort -k2,2nr
```


#### Hands-on Exercise 4: Quality Control Pipeline

```bash
# Create a comprehensive QC pipeline
find ~/bioproject -name "*.fastq" | \
while read file; do
    echo "Processing: $file"
    reads=$(grep -c "^@" "$file")
    avg_length=$(sed -n '2~4p' "$file" | awk '{sum+=length($0)} END {print sum/NR}')
    echo "$file: $reads reads, average length: $avg_length" >> qc_report.txt
done
```


## Week 2: Advanced Applications

### Day 5: Script Development and Automation (4 hours)

#### Professional Script Structure[^5][^6]

**Script Template**:

```bash
#!/bin/bash
# Script: biotools.sh
# Purpose: Bioinformatics file processing
# Author: [Your name]
# Date: [Date]

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Function definitions
validate_input() {
    if [[ ! -f "$1" ]]; then
        echo "Error: File $1 not found" >&2
        exit 1
    fi
}

# Main processing
main() {
    local input_file="$1"
    validate_input "$input_file"
    
    echo "Processing $input_file..."
    # Processing logic here
}

# Execute main function with all arguments
main "$@"
```

**Error Handling and Logging**:

```bash
# Comprehensive error handling
process_fastq() {
    local file="$1"
    local logfile="processing.log"
    
    {
        echo "$(date): Starting processing of $file"
        
        if ! grep -q "^@" "$file"; then
            echo "ERROR: Invalid FASTQ format in $file" >&2
            return 1
        fi
        
        local read_count=$(grep -c "^@" "$file")
        echo "INFO: Found $read_count reads in $file"
        
    } >> "$logfile" 2>&1
}
```


#### Hands-on Exercise 5: Production Script

Create a professional FASTQ validation script:

```bash
cat > fastq_validator.sh << 'EOF'
#!/bin/bash
set -euo pipefail

validate_fastq() {
    local file="$1"
    local errors=0
    
    # Check file exists
    if [[ ! -f "$file" ]]; then
        echo "ERROR: File $file does not exist" >&2
        return 1
    fi
    
    # Check FASTQ format
    local line_count=$(wc -l < "$file")
    if (( line_count % 4 != 0 )); then
        echo "ERROR: Line count not divisible by 4 in $file" >&2
        ((errors++))
    fi
    
    # Check header format
    if ! grep -q "^@" "$file"; then
        echo "ERROR: No sequence headers found in $file" >&2
        ((errors++))
    fi
    
    # Check quality line format
    if ! grep -q "^+" "$file"; then
        echo "ERROR: No quality headers found in $file" >&2
        ((errors++))
    fi
    
    if (( errors == 0 )); then
        echo "PASS: $file is valid FASTQ format"
        return 0
    else
        echo "FAIL: $file has $errors format errors"
        return 1
    fi
}

# Process all FASTQ files
for file in "$@"; do
    validate_fastq "$file"
done
EOF

chmod +x fastq_validator.sh
```


### Day 6: Bioinformatics Quality Control Integration (4 hours)

#### FASTQ Format Mastery[^15][^16]

**Understanding FASTQ Structure**[^15]:

- Line 1: Sequence identifier (starts with @)
- Line 2: Raw sequence
- Line 3: Quality identifier (starts with +)
- Line 4: Quality scores (ASCII encoded)

**Quality Score Interpretation**[^15]:

```bash
# Extract quality scores and convert to numeric
extract_quality_stats() {
    local fastq_file="$1"
    
    # Get quality lines (every 4th line starting from line 4)
    sed -n '4~4p' "$fastq_file" | \
    while IFS= read -r qual_line; do
        # Convert ASCII to numeric quality scores
        echo "$qual_line" | \
        python3 -c "
import sys
line = sys.stdin.read().strip()
scores = [ord(c) - 33 for c in line]  # Phred+33 encoding
print(f'Min: {min(scores)}, Max: {max(scores)}, Avg: {sum(scores)/len(scores):.2f}')
"
    done
}
```


#### Quality Control Integration[^7][^8]

**Automated QC Pipeline**:

```bash
#!/bin/bash
# Comprehensive FASTQ QC pipeline

run_quality_control() {
    local input_dir="$1"
    local output_dir="$2"
    
    mkdir -p "$output_dir"
    
    for fastq in "$input_dir"/*.fastq; do
        if [[ -f "$fastq" ]]; then
            echo "Processing $(basename "$fastq")..."
            
            # Basic statistics
            local reads=$(grep -c "^@" "$fastq")
            local total_bases=$(sed -n '2~4p' "$fastq" | tr -d '\n' | wc -c)
            local avg_length=$((total_bases / reads))
            
            # GC content analysis
            local gc_count=$(sed -n '2~4p' "$fastq" | tr -d '\n' | tr -cd 'GCgc' | wc -c)
            local gc_percent=$(( (gc_count * 100) / total_bases ))
            
            # Quality score analysis
            local qual_scores=$(sed -n '4~4p' "$fastq" | head -1000)
            
            # Generate report
            cat > "$output_dir/$(basename "$fastq" .fastq)_qc.txt" << EOF
FASTQ Quality Control Report
===========================
File: $(basename "$fastq")
Total Reads: $reads
Total Bases: $total_bases
Average Read Length: $avg_length
GC Content: $gc_percent%
EOF
            
            echo "QC complete for $(basename "$fastq")"
        fi
    done
}
```


#### Hands-on Exercise 6: Complete QC Workflow

```bash
# Create test dataset
mkdir -p ~/bioproject/qc_test
cd ~/bioproject/qc_test

# Generate test FASTQ files
create_test_fastq() {
    local filename="$1"
    local num_reads="$2"
    
    for ((i=1; i<=num_reads; i++)); do
        echo "@read_$i"
        echo "ATCGATCGATCGATCGATCGATCGATCGATCG"
        echo "+"
        echo "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII"
    done > "$filename"
}

create_test_fastq "sample1.fastq" 1000
create_test_fastq "sample2.fastq" 1500

# Run comprehensive QC
run_quality_control . ../qc_results
```


## Assessment Framework

### Competency Checkpoints

#### Week 1 Assessment: Command Line Proficiency

**Practical Exam** (30 minutes):

1. Navigate to a specified directory structure
2. Create and modify file permissions appropriately
3. Extract specific information from log files using text processing tools
4. Build a functional pipeline combining multiple commands

#### Week 2 Assessment: Script Development

**Capstone Project** (60 minutes):
Create a complete FASTQ processing script that:

1. Validates input file format
2. Generates comprehensive quality statistics
3. Implements proper error handling
4. Produces formatted output reports

### Scoring Rubric

| Competency Area | Beginner (0-60%) | Intermediate (61-80%) | Advanced (81-100%) |
| :-- | :-- | :-- | :-- |
| **Navigation** | Basic directory changes | Complex path manipulation | Efficient workflow navigation |
| **Permissions** | Simple chmod usage | Understanding security implications | Advanced permission strategies |
| **Text Processing** | Single command usage | Pipeline construction | Complex pattern matching |
| **Scripting** | Basic scripts | Error handling implementation | Production-ready automation |

## Resource Stack

### Essential References

- **The Linux Command Line** (William Shotts) - Comprehensive foundation[^1]
- **UNIX and Perl Primer for Biologists** - Domain-specific applications[^17]
- **Bash Scripting Tutorial** (LinuxConfig) - Advanced automation[^18]


### Online Practice Platforms

- **Rosalind.info** - Bioinformatics problem sets requiring UNIX skills
- **Command Line Challenge** - Interactive learning environment
- **Bioinformatics Algorithms (Rosalind)** - Applied problem solving


### Quality Control Tools Integration

- **FastQC** - Industry standard quality assessment[^7][^19]
- **MultiQC** - Aggregate reporting across samples[^7]
- **fqtools** - High-performance FASTQ manipulation[^20]


## Advanced Integration Pathways

### Connection to Subsequent Modules

This foundation enables progression to:

- **Python/Biopython** programming with command-line integration
- **R statistical analysis** with UNIX data preprocessing
- **Workflow management** using Snakemake/Nextflow
- **High-performance computing** environments


### Industry Relevance

Mastery of these competencies directly addresses:

- **Technical interview requirements** for bioinformatics positions[^21]
- **Clinical bioinformatics** ISO 15189 compliance needs
- **Research reproducibility** standards in genomics
- **Automated pipeline development** for high-throughput analysis


## Troubleshooting and Support

### Common Pitfalls

1. **Permission Errors**: Always check file ownership and permissions before processing
2. **Path Issues**: Use absolute paths in scripts for reliability
3. **Pipeline Failures**: Implement proper error checking in each pipeline stage
4. **Memory Management**: Monitor resource usage with large bioinformatics files

### Debug Strategies

```bash
# Enable debugging mode
set -x                    # Print commands before execution
set -e                    # Exit on first error
set -u                    # Exit on undefined variables

# Common debug commands
echo $?                   # Check exit status of last command
which command             # Verify command location
type command              # Check command type
```


## Conclusion

This comprehensive training manual provides the essential UNIX/Bash foundation required for professional bioinformatics practice. The competency-based approach ensures that learners develop both theoretical understanding and practical skills necessary for technical interviews, clinical compliance, and research excellence.

Upon completion, participants will possess the command-line proficiency expected in modern bioinformatics environments, enabling seamless progression to advanced computational biology techniques and automated workflow development.

<div style="text-align: center">⁂</div>

[^1]: https://hostman.com/tutorials/the-linux-command-line-a-short-guide-for-beginners/

[^2]: https://computing.stat.berkeley.edu/tutorial-unix-basics/

[^3]: https://www.meritshot.com/text-processing-using-grep-sed-and-awk/

[^4]: https://dev.to/abbazs/5-text-processing-tools-grep-sed-awk-cut-and-tr-to-score-some-marks-in-system-commands-oppe-2cjj

[^5]: https://www.freecodecamp.org/news/bash-scripting-tutorial-linux-shell-script-and-command-line-for-beginners/

[^6]: https://www.geeksforgeeks.org/linux-unix/bash-scripting-introduction-to-bash-and-bash-scripting/

[^7]: https://klebsiella2024.sanbi.ac.za/slides/Quality_Trimming.pdf

[^8]: https://pmc.ncbi.nlm.nih.gov/articles/PMC7844880/

[^9]: https://www.math.utah.edu/lab/unix/unix-commands.html

[^10]: https://cets.seas.upenn.edu/answers/chmod.html

[^11]: https://gcore.com/learning/how-to-manage-file-permissions-on-linux-using-chmod

[^12]: https://gps.uml.edu/tutorials/unix-linux/unix/chmod.htm

[^13]: https://www.youtube.com/watch?v=H9MLzwVJwsQ

[^14]: https://www.mssqltips.com/sqlservertip/5889/introduction-to-bash-scripting-pipes-and-redirections/

[^15]: https://en.wikipedia.org/wiki/FASTQ_format

[^16]: https://www.zymoresearch.com/blogs/blog/fastq-file-format

[^17]: https://decodingbiology.substack.com/p/unix-fundamentals-for-bioinformatics

[^18]: https://linuxconfig.org/bash-scripting-tutorial

[^19]: https://hbctraining.github.io/Intro-to-rnaseq-fasrc-salmon-flipped/lessons/06_qc_running_fastqc_sbatch.html

[^20]: https://pmc.ncbi.nlm.nih.gov/articles/PMC4908325/

[^21]: https://bioinformatics.stackexchange.com/questions/21601/shell-script-to-validate-fastq-issue

[^22]: https://www.youtube.com/watch?v=WVUDw0sxZxk

[^23]: https://ubuntu.com/tutorials/command-line-for-beginners

[^24]: https://www.cs.jhu.edu/~joanne/unixRC.pdf

[^25]: https://docs.vultr.com/how-to-process-text-with-bash-using-grep-sed-and-awk-commands

[^26]: https://www.youtube.com/watch?v=l2kodNMKroQ

[^27]: https://edlab-www.cs.umass.edu/unixroot/node72.html

[^28]: https://www-users.york.ac.uk/~mijp1/teaching/2nd_year_Comp_Lab/guides/grep_awk_sed.pdf

[^29]: https://hbctraining.github.io/Training-modules/planning_successful_rnaseq/lessons/QC_raw_data.html

[^30]: https://pmc.ncbi.nlm.nih.gov/articles/PMC6124377/

[^31]: https://www.rackspace.com/blog/fundamentals-shell-scripting

[^32]: https://help.dreamhost.com/hc/en-us/articles/214751018-UNIX-commands-Changing-permissions

[^33]: https://cerfacs.fr/coop/unix-terminal

[^34]: https://www.youtube.com/watch?v=tK9Oc6AEnR4

[^35]: https://www.ubuntumint.com/chmod-command-examples/

[^36]: https://www.youtube.com/watch?v=avg65oY7sj4

[^37]: https://www.w3schools.com/bash/

[^38]: https://www.youtube.com/watch?v=ngJG6Ix5FR4

[^39]: https://www.tutorialspoint.com/unix/index.htm

[^40]: https://www.shellscript.sh

[^41]: https://unix.stackexchange.com/questions/748648/bash-clarification-on-order-of-redirection-and-pipes

[^42]: https://www.redhat.com/en/blog/10-more-commands-terminal

[^43]: https://www.linode.com/docs/guides/differences-between-grep-sed-awk/

[^44]: https://www.redhat.com/en/blog/redirect-operators-bash

[^45]: https://www.unixtutorial.org/commands

[^46]: https://labex.io/tutorials/linux-text-processing-and-regular-expressions-18003

[^47]: https://www.freecodecamp.org/news/linux-terminal-piping-and-redirection-guide/

[^48]: https://www.softwaretestinghelp.com/file-manipulation-unix/

[^49]: https://www.youtube.com/watch?v=nMyoCgRbpCg

[^50]: https://stackoverflow.com/questions/77557914/how-bash-processes-pipes-and-redirections

[^51]: https://github.com/danielecook/Awesome-Bioinformatics

[^52]: https://github.com/TCP-Lab/x.FASTQ

[^53]: https://www.bioinformatics.babraham.ac.uk/projects/fastqc/

[^54]: https://academic.oup.com/bioinformatics/article/39/1/btad019/6986964

[^55]: https://stackoverflow.com/questions/59227841/some-tips-to-improve-a-bash-script-for-count-fastq-files

[^56]: https://academic.oup.com/bioinformatics/article/34/17/i884/5093234

[^57]: https://bioinformatics.ccr.cancer.gov/docs/unix-commands-for-beginners/unix_for_beginners/

[^58]: https://www.biostars.org/p/345891/

[^59]: https://www.hadriengourle.com/tutorials/qc/

[^60]: https://omicstutorials.com/mastering-bioinformatics-analysis-with-fastq-sequences-a-biologists-guide-to-unix-and-linux/

